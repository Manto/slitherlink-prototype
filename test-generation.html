<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Generation Test</title>
    <style>
        body {
            font-family: monospace;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border: 1px solid #ddd;
        }
        .pass { color: green; font-weight: bold; }
        .fail { color: red; font-weight: bold; }
        .info { color: blue; }
        pre {
            background: #f0f0f0;
            padding: 10px;
            border-radius: 3px;
            overflow-x: auto;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <h1>Slitherlink Puzzle Generation Tests</h1>

    <button id="runAllBtn">Run All Tests</button>
    <button id="clearBtn">Clear Results</button>

    <div id="results"></div>

    <script type="module">
        import { SlitherlinkGame } from './squareGame.js';

        function log(message, type = 'info') {
            const results = document.getElementById('results');
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `<span class="${type}">${message}</span>`;
            results.appendChild(section);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        function testCarvingOccurs() {
            log('TEST 1: Verifying that carving actually removes cells', 'info');

            const width = 6, height = 6;

            // Create a game instance for testing
            const game = new SlitherlinkGame('testCanvas');

            // Generate a puzzle and check
            game.puzzleWorker.postMessage({ type: 'square', width: 6, height: 6 });

            game.puzzleWorker.onmessage = (e) => {
                if (e.data.type !== 'square') return;
                const puzzle = e.data;

                // Count cells by checking which ones are inside the loop
                let totalEdges = 0;
                for (let i = 0; i <= height; i++) {
                    for (let j = 0; j < width; j++) {
                        if (puzzle.solution.horizontal[i][j] === 1) totalEdges++;
                    }
                }
                for (let i = 0; i < height; i++) {
                    for (let j = 0; j <= width; j++) {
                        if (puzzle.solution.vertical[i][j] === 1) totalEdges++;
                    }
                }

                // If carving happened, the perimeter should be less than a full 6x6 rectangle (24 edges)
                if (totalEdges < 24) {
                    log(`✓ PASS: Carving occurred. Total edges: ${totalEdges} (less than 24)`, 'pass');
                } else if (totalEdges === 24) {
                    log(`✗ FAIL: No carving occurred. Still a rectangle with ${totalEdges} edges`, 'fail');
                } else {
                    log(`✓ PASS: Complex shape with ${totalEdges} edges`, 'pass');
                }

                // Test that no entire rows or columns are empty
                testNoEmptyRowsOrColumns(puzzle.solution);

                // Test zero-score distribution
                testZeroScoreDistribution(puzzle);
                
                // Clean up
                game.destroy();
            };
        }

        function testNoEmptyRowsOrColumns(solution) {
            log('TEST 2: Verifying no entire rows or columns are empty', 'info');

            const width = 6, height = 6;

            // Determine which cells are inside by flood-filling from outside
            const inside = Array(height).fill(null).map(() => Array(width).fill(true));
            const outside = Array(height).fill(null).map(() => Array(width).fill(false));
            const queue = [];

            // Start from edges that are open
            for (let row = 0; row < height; row++) {
                if (solution.vertical[row][0] === 0) { queue.push([row, 0]); outside[row][0] = true; }
                if (solution.vertical[row][width] === 0) { queue.push([row, width - 1]); outside[row][width - 1] = true; }
            }
            for (let col = 0; col < width; col++) {
                if (solution.horizontal[0][col] === 0) { queue.push([0, col]); outside[0][col] = true; }
                if (solution.horizontal[height][col] === 0) { queue.push([height - 1, col]); outside[height - 1][col] = true; }
            }

            while (queue.length > 0) {
                const [row, col] = queue.shift();
                const neighbors = [
                    [row - 1, col, solution.horizontal[row][col]],
                    [row + 1, col, solution.horizontal[row + 1][col]],
                    [row, col - 1, solution.vertical[row][col]],
                    [row, col + 1, solution.vertical[row][col + 1]]
                ];
                for (const [newRow, newCol, edge] of neighbors) {
                    if (newRow >= 0 && newRow < height && newCol >= 0 && newCol < width &&
                        !outside[newRow][newCol] && edge === 0) {
                        outside[newRow][newCol] = true;
                        queue.push([newRow, newCol]);
                    }
                }
            }

            // Update inside array
            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    inside[row][col] = !outside[row][col];
                }
            }

            // Check rows
            let allRowsHaveCells = true;
            for (let row = 0; row < height; row++) {
                let hasCell = false;
                for (let col = 0; col < width; col++) {
                    if (inside[row][col]) {
                        hasCell = true;
                        break;
                    }
                }
                if (!hasCell) {
                    allRowsHaveCells = false;
                    log(`✗ FAIL: Row ${row} has no cells inside the loop`, 'fail');
                }
            }

            // Check columns
            let allColsHaveCells = true;
            for (let col = 0; col < width; col++) {
                let hasCell = false;
                for (let row = 0; row < height; row++) {
                    if (inside[row][col]) {
                        hasCell = true;
                        break;
                    }
                }
                if (!hasCell) {
                    allColsHaveCells = false;
                    log(`✗ FAIL: Column ${col} has no cells inside the loop`, 'fail');
                }
            }

            if (allRowsHaveCells && allColsHaveCells) {
                log('✓ PASS: All rows and columns have at least one cell', 'pass');
            }
        }

        function testZeroScoreDistribution(puzzle) {
            log('TEST 3: Verifying zero-score cell distribution', 'info');

            const width = puzzle.width;
            const height = puzzle.height;
            const numbers = puzzle.numbers;

            // Count cells with each score
            const scoreCounts = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0 };
            let totalCells = 0;

            for (let row = 0; row < height; row++) {
                for (let col = 0; col < width; col++) {
                    // Calculate score from solution
                    let score = 0;
                    if (puzzle.solution.horizontal[row][col] === 1) score++;
                    if (puzzle.solution.horizontal[row + 1][col] === 1) score++;
                    if (puzzle.solution.vertical[row][col] === 1) score++;
                    if (puzzle.solution.vertical[row][col + 1] === 1) score++;

                    scoreCounts[score]++;
                    totalCells++;
                }
            }

            const zeroPercent = (scoreCounts[0] / totalCells) * 100;

            log(`Score distribution: 0=${scoreCounts[0]}, 1=${scoreCounts[1]}, 2=${scoreCounts[2]}, 3=${scoreCounts[3]}, 4=${scoreCounts[4]}`, 'info');
            log(`Zero-score percentage: ${zeroPercent.toFixed(1)}%`, 'info');

            if (zeroPercent < 50) {
                log('✓ PASS: Zero-score percentage is reasonable', 'pass');
            } else {
                log('⚠ WARNING: High zero-score percentage', 'fail');
            }
        }

        function runAllTests() {
            clearResults();
            log('Starting puzzle generation tests...', 'info');
            testCarvingOccurs();
        }

        // Create a hidden canvas for testing
        const canvas = document.createElement('canvas');
        canvas.id = 'testCanvas';
        canvas.style.display = 'none';
        document.body.appendChild(canvas);

        // Bind button events
        document.getElementById('runAllBtn').addEventListener('click', runAllTests);
        document.getElementById('clearBtn').addEventListener('click', clearResults);
    </script>
</body>
</html>
